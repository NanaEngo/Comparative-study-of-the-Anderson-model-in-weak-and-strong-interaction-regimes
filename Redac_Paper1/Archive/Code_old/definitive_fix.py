
import json
import os

nb_path = '/home/taamangtchu/Documents/Github/Comparative-study-of-the-Anderson-model-in-weak-and-strong-interaction-regimes/Redac_Paper1/quantum_coherence_agrivoltaics_analysis_refined.ipynb'

with open(nb_path, 'r') as f:
    nb = json.load(f)

new_cell_source = [
    "class SensitivityAnalyzer:\n",
    "    \"\"\"\n",
    "    Comprehensive sensitivity analysis and uncertainty quantification for\n",
    "    quantum agrivoltaics simulations.\n",
    "    \"\"\"\n",
    "    \n",
    "    def __init__(self, quantum_simulator, agrivoltaic_model):\n",
    "        self.quantum_simulator = quantum_simulator\n",
    "        self.agrivoltaic_model = agrivoltaic_model\n",
    "        self.param_ranges = {\n",
    "            'temperature': (273, 320),\n",
    "            'dephasing_rate': (5, 50),\n",
    "            'transmission_center': (400, 700),\n",
    "            'transmission_width': (20, 150),\n",
    "            'dust_thickness': (0, 5)\n",
    "        }\n",
    "    \n",
    "    def local_sensitivity_analysis(self, base_params, param_name, n_points=20):\n",
    "        param_range = self.param_ranges.get(param_name, (0, 1))\n",
    "        param_values = np.linspace(param_range[0], param_range[1], n_points)\n",
    "        pce_values, etr_values, coherence_values = [], [], []\n",
    "        \n",
    "        for val in param_values:\n",
    "            current_params = base_params.copy()\n",
    "            current_params[param_name] = val\n",
    "            \n",
    "            if param_name in ['temperature', 'dephasing_rate']:\n",
    "                sim = QuantumDynamicsSimulator(self.quantum_simulator.H, \n",
    "                                               temperature=current_params.get('temperature', 295), \n",
    "                                               dephasing_rate=current_params.get('dephasing_rate', 20))\n",
    "                _, _, _, cohers, _, _, _, _, _, _, _ = sim.simulate_dynamics(time_points=np.linspace(0, 100, 20))\n",
    "                coherence_values.append(np.mean(cohers))\n",
    "                trans = self.agrivoltaic_model.calculate_spectral_transmission([0.5, 0.5, 0.5, 0.2])\n",
    "                pce_values.append(self.agrivoltaic_model.calculate_pce(trans))\n",
    "                etr_values.append(self.agrivoltaic_model.calculate_etr(trans))\n",
    "                \n",
    "            elif param_name in ['transmission_center', 'transmission_width']:\n",
    "                trans_params = {\n",
    "                    'center_wls': [current_params.get('transmission_center', 600)],\n",
    "                    'widths': [current_params.get('transmission_width', 100)],\n",
    "                    'peak_transmissions': [0.7], 'base_transmission': 0.1\n",
    "                }\n",
    "                trans = opv_transmission_parametric(self.agrivoltaic_model.wavelengths, trans_params)\n",
    "                pce_values.append(self.agrivoltaic_model.calculate_pce(trans))\n",
    "                etr_values.append(self.agrivoltaic_model.calculate_etr(trans))\n",
    "                coherence_values.append(0.0)\n",
    "                \n",
    "            elif param_name == 'dust_thickness':\n",
    "                self.agrivoltaic_model.update_environmental_conditions(dust_thickness=val)\n",
    "                trans = self.agrivoltaic_model.calculate_spectral_transmission([0.5, 0.5, 0.5, 0.2])\n",
    "                pce_values.append(self.agrivoltaic_model.calculate_pce(trans))\n",
    "                etr_values.append(self.agrivoltaic_model.calculate_etr(trans))\n",
    "                coherence_values.append(0.0)\n",
    "            else:\n",
    "                pce_values.append(0.0); etr_values.append(0.0); coherence_values.append(0.0)\n",
    "        \n",
    "        return param_values, np.array(pce_values), np.array(etr_values), np.array(coherence_values)\n",
    "    \n",
    "    def monte_carlo_uncertainty(self, n_samples=100, param_uncertainties=None):\n",
    "        if param_uncertainties is None:\n",
    "            param_uncertainties = {key: 0.1 for key in self.param_ranges.keys()}\n",
    "        pce_samples, etr_samples = [], []\n",
    "        base_params = {key: (val[0] + val[1])/2 for key, val in self.param_ranges.items()}\n",
    "        \n",
    "        for _ in range(n_samples):\n",
    "            sampled_params = {}\n",
    "            for key, base_val in base_params.items():\n",
    "                sampled_params[key] = np.clip(np.random.normal(base_val, base_val * param_uncertainties.get(key, 0.1)), \n",
    "                                              self.param_ranges[key][0], self.param_ranges[key][1])\n",
    "            \n",
    "            trans_params = {\n",
    "                'center_wls': [sampled_params['transmission_center']],\n",
    "                'widths': [sampled_params['transmission_width']],\n",
    "                'peak_transmissions': [0.7], 'base_transmission': 0.1\n",
    "            }\n",
    "            trans = opv_transmission_parametric(self.agrivoltaic_model.wavelengths, trans_params)\n",
    "            trans = opv_transmission_with_dust(self.agrivoltaic_model.wavelengths, trans, sampled_params['dust_thickness'], 'silica')\n",
    "            \n",
    "            pce_samples.append(self.agrivoltaic_model.calculate_pce(trans))\n",
    "            etr_samples.append(self.agrivoltaic_model.calculate_etr(trans))\n",
    "        \n",
    "        pce_samples, etr_samples = np.array(pce_samples), np.array(etr_samples)\n",
    "        return {\n",
    "            'pce': {'mean': np.mean(pce_samples), 'std': np.std(pce_samples), \n",
    "                    'ci_95': (np.percentile(pce_samples, 2.5), np.percentile(pce_samples, 97.5)), 'samples': pce_samples},\n",
    "            'etr': {'mean': np.mean(etr_samples), 'std': np.std(etr_samples), \n",
    "                    'ci_95': (np.percentile(etr_samples, 2.5), np.percentile(etr_samples, 97.5)), 'samples': etr_samples}\n",
    "        }\n",
    "\n",
    "    def comprehensive_sensitivity_report(self, n_points=10):\n",
    "        report = {}\n",
    "        base_params = {key: (val[0] + val[1])/2 for key, val in self.param_ranges.items()}\n",
    "        for param_name in ['temperature', 'dephasing_rate', 'transmission_center', 'transmission_width', 'dust_thickness']:\n",
    "            param_vals, pce_vals, etr_vals, coh_vals = self.local_sensitivity_analysis(base_params, param_name, n_points)\n",
    "            report[param_name] = {\n",
    "                'param_values': param_vals, 'pce_values': pce_vals, 'etr_values': etr_vals, 'coherence_values': coh_vals,\n",
    "                'pce_sensitivity': (pce_vals.max() - pce_vals.min()) / pce_vals.mean() if pce_vals.mean() > 0 else 0,\n",
    "                'etr_sensitivity': (etr_vals.max() - etr_vals.min()) / etr_vals.mean() if etr_vals.mean() > 0 else 0\n",
    "            }\n",
    "        return report\n",
    "\n",
    "agrivoltaic_model.update_environmental_conditions(dust_thickness=0.0)\n",
    "sensitivity_analyzer = SensitivityAnalyzer(quantum_sim, agrivoltaic_model)\n",
    "print(f\"Sensitivity Analyzer initialized\")\n",
    "mc_results = sensitivity_analyzer.monte_carlo_uncertainty(n_samples=100)\n",
    "print(f\"Monte Carlo Uncertainty Results calculated\")\n",
    "\n",
    "plt.figure(figsize=(12, 5))\n",
    "plt.subplot(1, 2, 1)\n",
    "plt.hist(mc_results['pce']['samples'], bins=20, alpha=0.7, color='blue', edgecolor='black')\n",
    "plt.axvline(mc_results['pce']['mean'], color='red', linestyle='--')\n",
    "plt.title('PCE Uncertainty Distribution')\n",
    "\n",
    "plt.subplot(1, 2, 2)\n",
    "plt.hist(mc_results['etr']['samples'], bins=20, alpha=0.7, color='green', edgecolor='black')\n",
    "plt.axvline(mc_results['etr']['mean'], color='red', linestyle='--')\n",
    "plt.title('ETR Uncertainty Distribution')\n",
    "plt.savefig(os.path.join(FIGURES_DIR, \"ETR_Uncertainty_Distribution.pdf\"), bbox_inches='tight', dpi=300)\n",
    "plt.show()\n",
    "\n",
    "print(f\"\\nPerforming comprehensive sensitivity analysis...\")\n",
    "sensitivity_report = sensitivity_analyzer.comprehensive_sensitivity_report(n_points=8)\n",
    "for param_name, data in sensitivity_report.items():\n",
    "    print(f\"  {param_name}: PCE sensitivity = {data['pce_sensitivity']:.3f}, ETR sensitivity = {data['etr_sensitivity']:.3f}\")\n"
]

for cell in nb['cells']:
    if cell['cell_type'] == 'code' and any('class SensitivityAnalyzer' in line for line in cell['source']):
        cell['source'] = new_cell_source
        break

with open(nb_path, 'w') as f:
    json.dump(nb, f, indent=1)

print("Definitive cell rewrite applied.")
